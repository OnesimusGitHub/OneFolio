/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useState } from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import { useThree, useFrame } from '@react-three/fiber'
import * as THREE from 'three'
import { useMotionValue, useSpring } from 'framer-motion'

export function GModel(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/models/rpg_monster_bat_free_download.glb')
  const { actions } = useAnimations(animations, group)
  
  
  const [position, setPosition] = useState([0, 0, 0])
  const [targetPosition, setTargetPosition] = useState([0, 0, 0])
  const [isMoving, setIsMoving] = useState(false)
  const [hovered, setHovered] = useState(false)
  
 
  const [mousePosition, setMousePosition] = useState([0, 0])
  
  
  const { camera, raycaster, viewport, mouse } = useThree()
  
  useEffect(() => {
    if(animations.length > 0) {
      actions[animations[1].name]?.play();
    }
  }, [actions, animations])

  
  useEffect(() => {
    const handleMouseMove = (event) => {
      event.preventDefault() 
      
      const mouse = new THREE.Vector2()
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
      
   
      const worldX = (mouse.x * viewport.width) / 2
      const worldY = (mouse.y * viewport.height) / 2
      
      setMousePosition([worldX, worldY])
    }
    

    const handleWheel = (event) => {
     if (hovered) {
    event.preventDefault()
    event.stopPropagation()
  }
    }
    
    const handleTouchMove = (event) => {
      event.preventDefault()
      event.stopPropagation()
    }
    
    const handleDragStart = (event) => {
      event.preventDefault()
      event.stopPropagation()
    }
    
    const handleContextMenu = (event) => {
      event.preventDefault()
      event.stopPropagation()
    }
    
   
    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('wheel', handleWheel, { passive: false })
    window.addEventListener('touchmove', handleTouchMove, { passive: false })
    window.addEventListener('dragstart', handleDragStart, { passive: false })
    window.addEventListener('contextmenu', handleContextMenu, { passive: false })
    
    return () => {
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('wheel', handleWheel)
      window.removeEventListener('touchmove', handleTouchMove)
      window.removeEventListener('dragstart', handleDragStart)
      window.removeEventListener('contextmenu', handleContextMenu)
    }
  }, [viewport])

 
  useEffect(() => {
    const handleClick = (event) => {
      event.preventDefault() 
      event.stopPropagation()
      
   
      const mouse = new THREE.Vector2()
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1
      
      
      const worldX = (mouse.x * viewport.width) / 2
      const worldY = (mouse.y * viewport.height) / 2
      const fixedZ = 0 
      
      setTargetPosition([worldX, worldY, fixedZ])
      setIsMoving(true)
    }
    
   
    const canvas = document.querySelector('canvas')
    if (canvas) {
      canvas.addEventListener('click', handleClick)
      return () => canvas.removeEventListener('click', handleClick)
    }
  }, [camera, raycaster, viewport])

 
  useFrame(() => {
    if (group.current) {
    
      const currentPos = new THREE.Vector3(...position)
      const cursorPos = new THREE.Vector3(mousePosition[0], mousePosition[1], 0)
      
      
      const direction = new THREE.Vector3()
      direction.subVectors(cursorPos, currentPos).normalize()
      
      if (direction.length() > 0) {
        
        const angle = Math.atan2(direction.x, direction.y)
        group.current.rotation.z = angle + Math.PI 
      }
      
    
      if (isMoving) {
        const target = new THREE.Vector3(...targetPosition)
        
        
        target.z = 0
        currentPos.z = 0
        
        const distance = currentPos.distanceTo(target)
        
        if (distance > 0.1) {
          
          currentPos.lerp(target, 0.03)
          setPosition([currentPos.x, currentPos.y, 0]) 
        } else {
          setIsMoving(false)
        }
      }
    }
  })
  
  const handlePointerEnter = (e) => {
    e.stopPropagation()
    setHovered(true)
    document.body.style.cursor = 'pointer'
  }
  
  const handlePointerLeave = (e) => {
    e.stopPropagation()
    setHovered(false)
    document.body.style.cursor = 'auto'
  }


  
  return (
    <group 
      ref={group} 
      {...props} 
      dispose={null}
      position={position}
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
      scale={hovered ? 1.1 : 1}
      rotation={[6, 9, Math.PI]}
    >
      <group name="Sketchfab_Scene">
        <group name="Sketchfab_model" rotation={[-Math.PI / 2, 0, 0]}>
          <group name="92a858a90090496fbbf01e56712da3d6fbx" rotation={[Math.PI / 2, 0, 0]}>
            <group name="Object_2">
              <group name="RootNode">
                <group name="monster_bat" />
                <group name="Armature" rotation={[-Math.PI / 2, 0, Math.PI]}>
                  <group name="Object_6">
                    <group name="Root001_01" rotation={[Math.PI / 2, 0, 0]}>
                      <group
                        name="StretchfootR001_02"
                        position={[-0.093, 0.19, -0.087]}
                        rotation={[-0.021, -0.097, -2.892]}>
                        <group name="LegfootR003_03" rotation={[-1.666, 0.058, -0.02]}>
                          <primitive object={nodes.LegfootR001_04} />
                        </group>
                      </group>
                      <group
                        name="Bodycenter001_08"
                        position={[-0.04, 0.382, 0.098]}
                        rotation={[0.45, -0.073, 0.02]}>
                        <primitive object={nodes.Bodyabdomen001_09} />
                        <primitive object={nodes.Headhead001_014} />
                        <primitive object={nodes.Bodychest001_026} />
                      </group>
                      <group
                        name="StretchfootL001_057"
                        position={[0.129, 0.178, -0.052]}
                        rotation={[-0.448, -0.025, 3.091]}>
                        <group name="LegfootL003_058" rotation={[-1.666, -0.058, 0.02]}>
                          <primitive object={nodes.LegfootL001_059} />
                        </group>
                      </group>
                    </group>
                  </group>
                </group>
              </group>
            </group>
          </group>
          <skinnedMesh
            name="Object_7"
            geometry={nodes.Object_7.geometry}
            material={materials.monster_bat}
            skeleton={nodes.Object_7.skeleton}
          />
          <skinnedMesh
            name="Object_8"
            geometry={nodes.Object_8.geometry}
            material={materials.monster_bat_eyes}
            skeleton={nodes.Object_8.skeleton}
          />
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/models/rpg_monster_bat_free_download.glb')